# https://school.programmers.co.kr/learn/courses/30/lessons/42746
# 코딩테스트연습 < 정렬 < 문제.가장 큰 수



# 입력
'''
1. 0 또는 양의 정수가 담긴 배열 numbers
- 1 <= numbers의 길이 <= 100,000
- 0 <= numbers의 원소 <= 1,000
'''



# 출력
'''
1. 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return
'''



# 코드 

# 접근방법
'''
- 각 숫자를 문자열로 변환한 후, 가장 앞에오는 숫자가 큰 정수를 앞에 먼저 배치할수록 가장 큰 수를 만들 수 있음
ex) numbers = ['6', '10', '2'] 👉 정렬 numbers = ['6', '2', '10']

- 가장 앞자리의 수가 같을 경우, 다음 자리의 수를 비교
ex) numbers = ['11', '12', '13'] 👉 정렬 numbers = ['13', '12', '11']

<정렬 방법>
ex) numbers = ['3', '30', '32', '33', '34', '4'] 
1. 문자열 숫자 가장 앞에 있는 숫자만 확인
    - ['3'('3'), '3'('30'), '3'('32'), '3'('33'), '3'('34'), '4']
2. 같은 위치에 해당하는 수가 더 클수록 우선순위가 높음(= 앞에 위치해야함)
    - ['4', '3'('3'), '3'('30'), '3'('32'), '3'('33'), '3'('34')]
    - 결과: ['4']
3. 다음 위치에 있는 숫자 확인
    - [''('3'), '0'('30'), '2'('32'), '3'('33'), '4'('34')]
4. 만약 해당 자리에 수가 없을 경우, 앞자리의 수와 동일한 수가 있다고 가정
    - ['3'('3'), '0'('30'), '2'('32'), '3'('33'), '4'('34')]
5. 같은 위치에 해당하는 수가 더 클수록 우선순위가 높음(= 앞에 위치해야함)
    - ['4'('34'), '3'('3'), '3'('33'), '2'('32'), '0'('30')]
    - 결과: ['4', '34', '3', '33', '32', '30']

<위 3번까지는 sort 함수를 사용하면 자동으로 진행되지만, 4번 조건을 sort 함수에 어떻게 적용할 수 있을까?>
- numbers의 원소는 최대 1,000까지만 존재 가능하다고 했으니까 단순히 각 number를 3번 증폭시킨 후 비교하면 됨

ex) numbers = ['3', '30', '32', '33', '34', '4'] 
               3 3 3
               3 0 3 0 3 0
               3 2 3 2 3 2
               3 3 3 3 3 3
               3 4 3 4 3 4 
               4 4 4
비교 자리수    ------------
         1)    [4]
         2)    [34, 33, 3, 32, 30]

ex) numbers = ['3', '331']

                3 3 3
                3 3 1 3 3 1
비교 자리수     ____________
         1)     []
         2)     []
         3)     [3, 331]
'''
import sys

sys.stdin = open('input_text/가장큰수.txt')

def solution(numbers):
    new_numbers = [str(num) for num in numbers]
    new_numbers.sort(key=lambda num: num * 3, reverse=True)

    # 0이 여러개인 경우
    if new_numbers[0] == '0':
        return '0'
    return ''.join(new_numbers)


# 실행 결과: 성공